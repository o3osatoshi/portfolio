## API Report File for "@o3osatoshi/toolkit"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Result } from 'neverthrow';
import { ResultAsync } from 'neverthrow';
import { z } from 'zod';
import { ZodError } from 'zod';

// @public
export type ActionData<TBase extends UnknownRecord = UnknownRecord> = null | TBase | undefined;

// @public
export type ActionState<T extends ActionData = UnknownRecord, E extends SerializedRichError = SerializedRichError> = {
    data: T;
    ok: true;
} | {
    error: E;
    ok: false;
} | never;

// @public
export function buildErrorSummary(details: RichErrorDetails | undefined): string | undefined;

// @public
export function buildHttpResponse<T = unknown>(data: T, response: Response, options?: BuildHttpResponseOptions): HttpResponse<T>;

// @public
export type BuildHttpResponseOptions = {
    cache?: {
        hit: boolean;
        key?: string;
    };
    retry?: {
        attempts: number;
    };
};

// @public
export function coerceErrorMessage(cause: unknown): string | undefined;

// @public
export function composeErrorName(layer: Layer, kind: Kind): string;

// @public
export function createEnv<T extends EnvSchema>(schema: T, opts?: CreateEnvOptions): EnvOf<T>;

// @public
export type CreateEnvOptions = {
    name?: string;
    source?: Record<string, string | undefined>;
};

// @public
export function createLazyEnv<T extends EnvSchema>(schema: T, opts?: CreateLazyEnvOptions): EnvOf<T>;

// @public
export type CreateLazyEnvOptions = CreateEnvOptions;

// @public
export function createUrlRedactor(options: UrlRedactorOptions): (url: string) => string;

// @public
export function decode(value: string): Result<JsonContainer, RichError>;

// @public
export function deserializeResponseBody(response: Response): Promise<unknown>;

// @public
export function deserializeRichError(input: unknown, options?: DeserializeRichErrorOptions): RichError;

// @public
export type DeserializeRichErrorFailure = {
    input: unknown;
    issues: DeserializeRichErrorIssue[];
};

// @public
export type DeserializeRichErrorIssue = {
    code: string;
    message: string;
    path: string;
};

// @public
export type DeserializeRichErrorOptions = {
    action?: string | undefined;
    code?: string | undefined;
    i18nKey?: string | undefined;
    layer?: Layer | undefined;
    meta?: JsonObject | undefined;
    source?: string | undefined;
};

// @public
export function encode(value: unknown): Result<string, RichError>;

// @public
export type Env = "development" | "local" | "production" | "staging";

// @public
export type EnvOf<T extends EnvSchema> = {
    [K in keyof T]: z.infer<T[K]>;
};

// @public
export type EnvSchema = Record<string, z.ZodTypeAny>;

// @public
export function err(error: RichError): ActionState<never, SerializedRichError>;

// @public
export type ErrorHttpResponse = {
    body: SerializedError;
    statusCode: ErrorStatusCode;
};

// @public
export type ErrorNameParts = {
    kind?: Kind;
    layer?: Layer;
};

// @public
export type ErrorStatusCode = 400 | 401 | 403 | 404 | 405 | 408 | 409 | 422 | 429 | 500 | 502 | 503 | 504;

// @public
export function extractErrorMessage(cause: unknown): string | undefined;

// @public
export function extractErrorName(cause: unknown): string | undefined;

// @public
export type FetchRequest = {
    method?: string;
    url?: string;
};

// @public
export function formatFetchTarget(input: {
    request?: FetchRequest | undefined;
}): string | undefined;

// @public
export function formatHttpStatusReason(input: FormatHttpStatusReasonOptions): string;

// @public
export type FormatHttpStatusReasonOptions = {
    maxPayloadLength?: null | number;
    payload: unknown;
    response: HttpStatusLike;
    serviceName: string;
};

// @public
export function formatPayloadPreview(payload: unknown): string;

// @public
export type HttpRequest = {
    method?: string;
    url: string;
};

// @public
export type HttpResponse<T = unknown> = {
    cache?: {
        hit: boolean;
        key?: string;
    };
    data: T;
    response: {
        headers: Headers;
        ok: boolean;
        redirected?: boolean;
        status: number;
        statusText: string;
        url: string;
    };
    retry?: {
        attempts: number;
    };
};

// @public
export type HttpStatusKind = Extract<Kind, "BadGateway" | "BadRequest" | "Forbidden" | "Internal" | "NotFound" | "RateLimit" | "Timeout" | "Unauthorized">;

// @public
export type HttpStatusLike = {
    status: number;
    statusText: string;
};

// @public
export function httpStatusToKind(status: number): HttpStatusKind;

// @public
export function isDeserializableBody(res: Response): boolean;

// @public
export function isDeserializableResponse(response: Response): boolean;

// @public
export function isRichError(error: unknown): error is RichError;

// @public
export function isSerializedError(v: unknown): v is SerializedError;

// @public
export function isSerializedRichError(v: unknown): v is SerializedRichError;

// @public
export function isZodError(e: unknown): e is ZodError;

// @public
export type JsonArray = JsonValue[];

// @public
export const jsonArraySchema: z.ZodType<JsonArray>;

// @public
export type JsonContainer = JsonArray | JsonObject;

// @public
export type JsonObject = {
    [key: string]: JsonValue;
};

// @public
export const jsonObjectSchema: z.ZodType<JsonObject>;

// @public
export type JsonPrimitive = boolean | null | number | string;

// @public
export const jsonPrimitiveSchema: z.ZodUnion<readonly [z.ZodString, z.ZodNumber, z.ZodBoolean, z.ZodNull]>;

// @public
export type JsonValue = JsonArray | JsonObject | JsonPrimitive;

// @public
export const jsonValueSchema: z.ZodType<JsonValue>;

// @public
export type Kind = z.infer<typeof kindSchema>;

// @public
export const kindSchema: z.ZodEnum<{
    BadGateway: "BadGateway";
    BadRequest: "BadRequest";
    Canceled: "Canceled";
    Conflict: "Conflict";
    Forbidden: "Forbidden";
    Internal: "Internal";
    MethodNotAllowed: "MethodNotAllowed";
    NotFound: "NotFound";
    RateLimit: "RateLimit";
    Serialization: "Serialization";
    Timeout: "Timeout";
    Unauthorized: "Unauthorized";
    Unavailable: "Unavailable";
    Unprocessable: "Unprocessable";
    Validation: "Validation";
}>;

// @public
export type Layer = z.infer<typeof layerSchema>;

// @public
export const layerSchema: z.ZodEnum<{
    Application: "Application";
    Auth: "Auth";
    Domain: "Domain";
    External: "External";
    Infrastructure: "Infrastructure";
    Interface: "Interface";
    Persistence: "Persistence";
    Presentation: "Presentation";
}>;

// @public
export type NewFetchError = {
    cause?: unknown;
    details?: RichErrorDetails | undefined;
    isOperational?: boolean | undefined;
    kind?: Kind | undefined;
    request?: FetchRequest | undefined;
} & Omit<NewRichError, "details" | "isOperational" | "kind" | "layer">;

// @public
export function newFetchError(input: NewFetchError): RichError;

// @public
export type NewRichError = {
    cause?: unknown;
    code?: string | undefined;
    details?: RichErrorDetails | undefined;
    i18n?: RichErrorI18n | undefined;
    isOperational: boolean;
    kind: Kind;
    layer: Layer;
    meta?: JsonObject | undefined;
};

// @public
export function newRichError(params: NewRichError): RichError;

// @public
export type NewZodError = {
    cause?: undefined | unknown;
    details?: RichErrorDetails | undefined;
    isOperational?: boolean | undefined;
    issues?: undefined | ZodIssue[];
    layer?: Layer | undefined;
} & Omit<NewRichError, "details" | "isOperational" | "kind" | "layer">;

// @public
export function newZodError(options: NewZodError): RichError;

// @public
export function normalizeBaseUrl(baseUrl: string): string;

// @public
export function ok<T extends ActionData>(data: T): ActionState<T, never>;

// @public
export function parseErrorName(name: string | undefined): ErrorNameParts;

// @public
export function parseWith<T extends z.ZodType>(schema: T, ctx: {
    action: string;
    layer?: Layer;
}): (input: unknown) => Result<z.infer<T>, RichError>;

// @public
export function resolveAbortSignal(options?: ResolveAbortSignalOptions): ResolvedAbortSignal;

// @public
export type ResolveAbortSignalOptions = {
    signal?: AbortSignal | undefined;
    timeoutMs?: number | undefined;
    timeoutReason?: undefined | unknown;
};

// @public
export type ResolvedAbortSignal = {
    cleanup: () => void;
    signal?: AbortSignal | undefined;
};

// @public
export function resolveErrorInfo(error: unknown): {
    kind?: Kind;
    layer?: Layer;
};

// @public
export function resolveErrorKind(error: unknown): Kind | undefined;

// @public
export function resolveErrorLayer(error: unknown): Layer | undefined;

// @public
export function resolveOperationalFromKind(kind: Kind): boolean;

// @public
export class RichError extends Error {
    // (undocumented)
    readonly [RICH_ERROR_BRAND] = true;
    constructor(params: NewRichError, messageOverride?: string);
    // (undocumented)
    readonly code: string | undefined;
    // (undocumented)
    readonly details: RichErrorDetails | undefined;
    // (undocumented)
    readonly i18n: RichErrorI18n | undefined;
    // (undocumented)
    readonly isOperational: boolean;
    // (undocumented)
    readonly kind: Kind;
    // (undocumented)
    readonly layer: Layer;
    // (undocumented)
    readonly meta: JsonObject | undefined;
}

// @public
export type RichErrorDetails = z.infer<typeof richErrorDetailsSchema>;

// @public
export const richErrorDetailsSchema: z.ZodObject<{
    action: z.ZodOptional<z.ZodString>;
    hint: z.ZodOptional<z.ZodString>;
    impact: z.ZodOptional<z.ZodString>;
    reason: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;

// @public
export type RichErrorI18n = z.infer<typeof richErrorI18nSchema>;

// @public
export const richErrorI18nSchema: z.ZodObject<{
    key: z.ZodString;
    params: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<readonly [z.ZodString, z.ZodNumber, z.ZodBoolean]>>>;
}, z.core.$strip>;

// @public
export type RichResult<T> = Result<T, RichError>;

// @public
export type RichResultAsync<T> = ResultAsync<T, RichError>;

// @public
export type SerializedCause = Exclude<SerializedError["cause"], undefined>;

// @public
export type SerializedError = z.infer<typeof serializedErrorSchema>;

// @public
export const serializedErrorSchema: z.ZodType<{
    cause?: string | undefined | z.infer<typeof serializedErrorSchema>;
    code?: string | undefined;
    details?: RichErrorDetails | undefined;
    i18n?: RichErrorI18n | undefined;
    isOperational?: boolean | undefined;
    kind?: Kind | undefined;
    layer?: Layer | undefined;
    message: string;
    meta?: undefined | z.infer<typeof jsonObjectSchema>;
    name: string;
    stack?: string | undefined;
}>;

// @public
export type SerializedRichError = {
    isOperational: boolean;
    kind: Kind;
    layer: Layer;
} & Omit<SerializedError, "isOperational" | "kind" | "layer">;

// @public
export const serializedRichErrorSchema: z.ZodType<SerializedRichError>;

// @public
export type SerializeOptions = {
    depth?: number | undefined;
    includeStack?: boolean | undefined;
};

// @public
export function serializeRichError(error: RichError, opts?: SerializeOptions): SerializedRichError;

// @public
export function sleep(ms: number, input?: SleepOptions): ResultAsync<void, RichError>;

// @public
export type SleepOptions = {
    signal?: AbortSignal;
};

// @public
export function summarizeZodError(err: ZodError): string;

// @public
export function summarizeZodIssue(issue: ZodIssue): string;

// @public
export function toHttpErrorResponse(error: Error, status?: ErrorStatusCode, options?: SerializeOptions): ErrorHttpResponse;

// @public
export function toRichError(error: unknown, fallback?: Partial<NewRichError>): RichError;

// @public
export function truncate(value: string, maxLen?: null | number): string;

// @public
export function tryDeserializeRichError(input: unknown): Result<RichError, DeserializeRichErrorFailure>;

// @public
export type UnknownRecord = Record<string, unknown>;

// @public
export function unwrapResultAsyncOrThrow<T, E extends Error>(result: ResultAsync<T, E>): Promise<T>;

// @public
export type UrlRedactorOptions = {
    placeholder?: string;
    secrets: Array<string | undefined>;
};

// @public
export function userMessageFromError(error: Error): string;

// @public
export type ZodIssue = z.core.$ZodIssue;

// (No @packageDocumentation comment for this package)

```
